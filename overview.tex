\section{概述}
本章节首先简要介绍了Vulkan，以及它所解决的问题。然后，我们将会看到如何使用Vulkan来绘制一个三角形，建立Vulkan的基本使用思路。最后，我们将会介绍Vulkan API的基本结构和使用方式。

\subsection{Vulkan起源}

Vulkan是作为一个跨平台的图形API设计的。以往许多图形API采用固定功能渲染管线设计，应用程序按照一定格式提交顶点数据，配置光照和着色选项。

随着显卡架构逐渐成熟，提供了越来越多的可编程功能，这些功能被集成到原有的API中。造成驱动程序要做的工作越来越复杂，应用程序开发者要处理的兼容性问题也越来越多。随着移动浪潮到来，人们对移动GPU的要求也越来越高，但以往的图形API不能够进行更加精准地控制来提升效率，对多线程的支持也非常不足，导致没有发挥出图形硬件真正的潜力。

由于没有历史包袱，Vulkan完全按照现代图形架构设计，提供了更加详细的API给开发者，大大减少了驱动程序的开销，允许多个线程并行创建和提交指令，使用标准化的着色器字节码，将图形和计算功能进行统一。

\subsection{画一个三角形}

现在，让我们来看下如何使用Vulkan绘制三角形。这里用到的所有概念会在下一章节进行详细地说明。

\textbf{步骤1：实例和物理设备选择}

我们的应用程序是通过VkInstance来使用Vulkan API的。应用程序创建VkInstance后，就可以查询Vulkan支持的硬件，选择其中一个或多个VkPhysicalDevices进行操作。我们可以通过查询设备属性，选择一个适合我们的设备。

\textbf{步骤2：逻辑设备和队列族}

选择完合适的硬件设备后，我们需要使用更详细的VkPhysicalDevice特性(比如多视口，64位浮点)来创建一个逻辑设备VkDevice。还需要指定我们想要使用的队列族。Vulkan将诸如绘制指令、内存操作提交到VkQueue中，进行异步执行。队列由队列族分配，每个队列族支持一个特定操作集合。比如，图形，计算和内存传输操作可以使用独立的队列族。队列族可以作为物理设备选择时的一个参考。比如，一个支持Vulkan的设备可能没有提供任何图形功能，但对于支持Vulkan的显卡设备而言，支持所有队列操作。

\textbf{步骤3：窗口表面和交换链}

如果不是进行离屏渲染，通常我们需要创建一个窗口来显示渲染的图像。这一工作可以通过原生平台的窗口API或像GLFW或SDL这样的库来完成，在这里，我们使用的是GLFW，有关GLFW的更多信息，我们会在下一章介绍。

我们还需要两个组件才能完成窗口渲染：窗口表面(VkSurfaceKHR)和交换链(VkSwapChainKHR)。可以注意到这两个组件都有一个KHR后缀，这表示它们属于Vulkan扩展。Vulkan API本身是完全平台无关的，需要我们使用WSI(Window System Interface，窗口系统接口)扩展与原生的窗口管理器进行交互。表面(Surface)是一个跨平台抽象，通常它是由原生窗口系统句柄作为参数实例化得到。不过，这一部分工作，GLFW已经帮我们处理了，所以不用我们关心。

交换链是一个渲染目标集合。它可以保证我们正在渲染的图像和当前屏幕图像是两个不同的图像。这可以确保显示出来的图像是完整的。每次绘制一帧时，可以请求交换链提供一张图像。绘制完成后，图像被返回到交换链中，在之后某个时刻，图像被显示到屏幕上。渲染目标数量和图像显示到屏幕的时机依赖于显示模式。常用的显示模式有双缓冲(vsync，垂直同步)和三缓冲。我们将在创建交换链章节讨论这些问题。

\textbf{步骤4：图像视图和帧缓冲}

从交换链获取图像后，还不能直接在图像上进行绘制，需要将图像先包装进VkImageView和VkFramebuffer中去。一个图像视图可以引用图像的特定部分，一个帧缓冲可以引用图像视图作为颜色，深度和模板目标。交换链中可能有多个不同的图像，我们可以预先为它们每一个都创建好图像视图和帧缓冲，然后在绘制时选择对应的那个。

\textbf{步骤5：渲染流程}

渲染流程描述了渲染操作使用的图像类型，图像的使用方式，图像的内容如何处理。对于我们这个绘制三角形的程序，我们使用了一张图像作为颜色目标，在执行绘制操作前清除整个图像。渲染流程只描述了图像的类型，图像绑定是通过VkFramebuffer完成的。

\textbf{步骤6：图形管线}

Vulkan的图形管线可以通过VkPipeline对象建立。它描述了显卡的可配置状态，比如视口大小和深度缓冲操作，以及使用VkShaderModule对象的可编程状态。VkShaderModule对象由着色器字节码创建而来。驱动程序知道哪些渲染目标被图形管线使用。

Vulkan与之前的图形API的一个最大不同是几乎所有图形管线的配置都需要提前完成。这意味着如果我们想要使用另外一个着色器或者顶点布局，需要重新创建整个图形管线。显然效率很低，这迫使我们提前创建出所有我们需要的图形管线，在需要时直接使用已经创建好的图形管线。图形管线只有很少一部分配置可以动态修改，比如视口大小和清除颜色。图形管线的所有状态也需要显式地描述，比如，不存在默认的颜色混合状态。

这样做的好处类似于预编译相比于即时编译，驱动程序可以有更大的优化空间，并且以图形管线为切换单位，渲染效果的预期也变得十分容易，不用担心切换时，遗漏某个微小的设置，造成结果的巨大差异。

\textbf{步骤7：指令池和指令缓冲}

之前提到，Vulkan的许多操作需要提交到队列才能执行。这些操作首先被记录到一个VkCommandBuffer对象中，然后提交给队列。VkCommandBuffer对象由一个关联了特定队列族的VkCommandPool分配而来。为了绘制三角形，我们需要记录下列操作到VkCommandBuffer对象中去：

\begin{itemize}
	\item 开始渲染
	\item 绑定图形管线
	\item 绘制三角形
	\item 结束渲染
\end{itemize}

由于帧缓冲绑定的图像依赖于交换链给我们的图像，我们可以提前为每个图像建立指令缓冲，然后在绘制时，直接选择对应的指令缓冲使用。当然在每一帧记录指令缓冲也是可以的，但这样做效率很低。

\textbf{步骤8：主循环}

将绘制指令包装进指令缓冲后，主循环变得非常直白。我们首先使用vkAcquireNextImageKHR函数从交换链获取一张图像。接着使用vkQueueSubmit函数提交图像对应的指令缓冲。最后，使用vkQueuePresentKHR函数将图像返回给交换链，显示图像到屏幕。

提交给队列的操作会被异步执行。我们需要采取同步措施比如信号量来确保操作按正确的顺序执行。绘制指令的执行必须在获取图像之后，否则，可能会出现读写冲突，屏幕正在读取图像数据的同时，绘制操作在进行绘制操作，造成屏幕读取显示的数据并非来自同一帧。同样，vkQueuePresentKHR函数调用需要在绘制完成后进行。

\subsection{总结}

本章节通过绘制一个简单的三角形来使读者建立Vulkan的基本使用思路。通常，一个真正实用的程序会包含更多的步骤，比如分配顶点缓冲，创建Uniform缓冲，上传纹理图像等等。但为了降低学习难度，我们从最简单的形式开始，逐步复杂化。

对于绘制一个三角形，我们需要采取的步骤包括：

\begin{itemize}
	\item 创建一个VkInstance
	\item 选择一个支持Vulkan的图形设备(VkPhysicalDevice)
	\item 为绘制和显示操作创建VkDevice和VkQueue
	\item 创建一个窗口，窗口表面和交换链
	\item 将交换链图像包装进VkImageView
	\item 创建一个渲染层指定渲染目标和使用方式
	\item 为渲染层创建帧缓冲
	\item 配置图形管线
	\item 为每一个交换链图像分配指令缓冲
	\item 从交换链获取图像进行绘制操作，提交图像对应的指令缓冲，返回图像到交换链
\end{itemize}

看起来步骤非常多，但其实每一步都非常简单。在接下来的章节，我们会对每一步进行非常详细地说明。如果你对程序中的某一步感到困惑，可以回来参考一下本章节。

\subsection{API概念}

本小节对Vulkan API的结构进行简要的介绍。

\subsubsection{编码约定}

Vulkan的所有函数、枚举和结构体都被定义在vulkan.h中，我们可以在Vulkan SDK中找到这一头文件。在下一章节，我们会介绍如何安装Vulkan SDK。

Vulkan API的函数都带有一个小写的vk前缀，枚举和结构体名带有一个Vk前缀，枚举值带有一个VK\_前缀。Vulkan对结构体非常依赖，大量函数的参数由结构体提供。比如，Vulkan创建对象的一般形式如下：

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20},basicstyle=\small,numbers=left, numberstyle=\tiny,breaklines = true]
VkXXXCreateInfo createInfo = {};
createInfo.sType = VK_STRUCTURE_TYPE_XXX_CREATE_INFO;
createInfo.pNext = nullptr;
createInfo.foo = ...;
createInfo.bar = ...;

VkXXX object;
if (vkCreateXXX(&createInfo, nullptr, &object) != VK_SUCCESS) {
	std::cerr << "failed to create object" << std::endl;
	return false;
}
\end{lstlisting}

Vulkan的许多结构体需要我们通过设置sType成员变量来显式指定结构体类型。结构体的pNext成员可以指向一个扩展的结构体，在本教程，我们不使用它，它被设置为nullptr。Vulkan中创建和销毁对象的函数都有一个VkAllocationCallbacks参数，可以被用来自定义内存分配器，在这里，我们不使用它，将其设置为nullptr。

几乎所有Vulkan都会返回一个VkResult来表示调用的执行情况，它的值要么是VK\_SUCCESS，要么是一个错误代码。Vulkan规范文档描述了这些函数返回的错误代码的意义。

\subsection{校验层}

之前提到，Vulkan的设计目标是高性能、低驱动程序开销。所以，默认情况下，它提供的错误检测和调试功能非常有限。驱动程序会在发生错误时直接崩溃，而不是返回一个错误代码。这可能导致对于某种显卡可以工作，不会崩溃，但对于其它显卡无法工作，驱动程序崩溃。

可以通过Vulkan的校验层(Validation layers)特性来进行一定的错误检查措施。校验层是一段被插入在Vulkan API和驱动程序之间的代码，可以对Vulkan API函数的参数进行检查，跟踪内存分配。我们可以在开发期开启校验层，然后在发布程序时关闭校验层，减少性能损失。校验层可以完全自己编写，但为了方便，我们的教程直接使用了Vulkan SDK提供的一组校验层。我们通过注册的回调函数来接受来自校验层的调试信息。

由于Vulkan的每个操作都要显式定义，加之校验层的使用，调试使用Vulkan的程序要比调试使用OpenGL和Direct3D的程序轻松太多。

接下来让我们配置开发环境，开始我们的Vulkan编程之旅吧！

\newpage
